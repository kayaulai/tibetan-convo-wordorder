---
title: "R Notebook"
output: html_notebook
editor_options: 
  chunk_output_type: inline
---

# Library and data import

The first step is to import a bunch of necessary packages:

```{r message=FALSE}
library(tidyverse)
library(tidyr)
library(rlang)
library(rezonateR)
library(here)
library(stringr)
library(glue)
source(here("src", "utils", "files.R"))
```

Then we can import the data, which I save as a data file too:

```{r warning=FALSE}
discoNames = getCurrDocNames()
df = discoNames %>%
    map(function(x) suppressMessages(rez_load(here("data", "02_rezrDF", glue("{x}.Rdata"))))) %>%
    reduce(rez_bind_rows)

```

# Features

Turning features into their final encodings for the model:

```{r}
featsChosen = c("argTypeNew",
           "noPrevMentions", "noPrevZero", "noNextMentions", "noNextZero",
           "haveBridges", "identifiable", "local", "justFirst", "justLast", 
            "interrog", "animate",
           "self", "addressee", "length", "pronom", "noPrevMentionsFar", "noNextMentionsFar")
featsQuant = c("noPrevMentions", "noPrevZero", "noNextMentions", "noNextZero",
               "justFirst", "justLast", "length", "noPrevMentionsFar", "noNextMentionsFar")
featsQual = setdiff(featsChosen, featsQuant) %>% c("topic")
featsBinary = setdiff(featsQual, "argTypeNew")

log_p1 = function(x) log(x + 1)
df = df %>% mutate(identifiable = factor(identifiable, levels = c("n", "i"))) %>%
        mutate(across(all_of(featsBinary), as.integer)) %>%
        mutate(argType = as.factor(argType)) %>%
        mutate(argTypeNew = as.factor(case_when(argType == "T" ~ "P",
                                                argType == "A" ~ "Base",
                                                argType == "S" ~ "Base",
                                                argType == "COPS" ~ "Base",
                                                argType == "COPLOC" ~ "Base",
                                     T ~ argType))) %>%
        mutate(across(all_of(featsQuant), log_p1)) 
```

# Quick checks

Quick check to make sure everything is working as intended:

```{r}
clauses = df %>% group_by(verbID) %>% count
message(glue("Number of clauses: {nrow(clauses)}"))

```

Singleton clauses:

```{r}
singletons = clauses %>% filter(n == 1)
if(nrow(singletons) > 0){
    View(singletons)
    write_csv(singletons, here("output", "debug", "analysis", "singletons.csv"))
    message(glue("You have some singleton clauses; please check the output at {here(\"output\", \"debug\", \"analysis\", \"singletons.csv\")}."))
}

```

NAs inside columns:

```{r}
cols_na_present = df %>% sapply(function(x) any(is.na(x)))
na_cols = intersect(featsChosen, names(cols_na_present)[which(cols_na_present)])
if(length(na_cols) > 0){
    na_rows = df %>% filter(if_any(all_of(featsChosen), is.na))
    write_csv(na_rows, here("output", "debug", "analysis", "na_rows.csv"))
    message(glue("The following columns have NA values: {paste0(na_cols, collapse = ", ")}"))
    message(glue("Please check the output at {here(\"output\", \"debug\", \"analysis\", \"na_rows\")}."))
}
```

# Saving

Then we save the data in two formats - RDS and CSV:

```{r}
saveRDS(df, here(glue("output", "analysis", "wodata.rds")))
write_csv(df, here("output", "analysis_data", glue("all.csv")))
```